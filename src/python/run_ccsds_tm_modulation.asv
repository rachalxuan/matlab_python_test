function json_str = run_ccsds_tm_modulation(paramsJson)
    % run_ccsds_tm_modulation 
    % 【最终智能对齐版】
    % 1. 集成 Helper 方案2 解码逻辑
    % 2. 修复 GMSK 同步配置
    % 3. 【新增】BER 计算增加 "盲对齐搜索"，彻底解决同步带来的随机延迟问题
    
    tStart = tic;
    try, feature('DefaultCharacterSet', 'UTF-8'); catch, end 
    
    try
        %% 1. 解析参数
        if nargin < 1 || isempty(paramsJson), error('No parameters received'); end
        opt = jsondecode(paramsJson);
        
        makeNum = @(f) str2double(strrep(string(f), ',', '')); 
        if ischar(opt.symbolRate), fSym = makeNum(opt.symbolRate); else, fSym = double(opt.symbolRate); end
        if ischar(opt.sps), sps = makeNum(opt.sps); else, sps = double(opt.sps); end
        
        % 默认开启 ASM 以保证同步稳定性 (如果前端没传)
        hasRandomizer = false; if isfield(opt, 'hasRandomizer'), hasRandomizer = opt.hasRandomizer; end
        hasASM = true; % 【修改】默认为 true，增加鲁棒性
        if isfield(opt, 'hasASM'), hasASM = opt.hasASM; end

        %% 2. 发送端配置
        args = {
            'SamplesPerSymbol', sps, ...
            'HasRandomizer', hasRandomizer, ...
            'HasASM', hasASM
        };
        
        isAPSK = contains(opt.modType, 'APSK');
        modStr = string(opt.modType);
        
        if isAPSK
            if isfield(opt, 'acmFormat'), acmFmt = double(opt.acmFormat); else, acmFmt = 14; end
            args = [args, { ...
                'WaveformSource', 'flexible advanced coding and modulation', ...
                'ACMFormat', acmFmt, ...
                'NumBytesInTransferFrame', 1115, ... 
                'PulseShapingFilter', 'Root Raised Cosine' ...
            }];
            rolloff = 0.35;
        else
            args = [args, {'WaveformSource', 'synchronization and channel coding'}];
            args = [args, {'NumBytesInTransferFrame', 1115}];
            args = [args, {'Modulation', modStr}];
            
            if isfield(opt, 'channelCoding'), codeStr = lower(string(opt.channelCoding)); else, codeStr = 'none'; end
            args = [args, {'ChannelCoding', codeStr}];
            
            if isfield(opt, 'RolloffFactor'), rolloff = str2double(string(opt.RolloffFactor)); else, rolloff = 0.5; end
            btVal = 0.5;
            if isfield(opt, 'BandwidthTimeProduct'), btVal = str2double(string(opt.BandwidthTimeProduct)); end

            if contains(modStr, 'GMSK')
                 args = [args, {'BandwidthTimeProduct', btVal}]; 
            else
                 args = [args, {'RolloffFactor', rolloff}];
            end
            
            switch modStr
                case {'BPSK', 'QPSK', '8PSK', 'OQPSK'}
                    args = [args, {'FilterSpanInSymbols', 10}];
            end
             
             if contains(codeStr, {'turbo', 'ldpc'}) && isfield(opt, 'CodeRate')
                 args = [args, {'CodeRate', string(opt.CodeRate)}];
             end
        end
        
        tmWaveGen = ccsdsTMWaveformGenerator(args{:});
        
        if contains(modStr, 'GMSK')
            infoStruct = get(tmWaveGen);
            fprintf('[CHECK] 发送端 GMSK BT 值 = %.4f\n', infoStruct.BandwidthTimeProduct);
        end
        
        %% 3. 生成数据
        Fs = fSym * sps;
        bitsPerFrame = tmWaveGen.NumInputBits;
        numHeaderBits = 8; 
        numPayloadBits = bitsPerFrame - numHeaderBits;
        
        numWarmUp = 5; numRealFrames = 20; totalFrames = numWarmUp + numRealFrames;
        msg = []; validTxFrames = {}; 
        for i = 1:totalFrames
            header = de2bi(mod(i-1, 256), numHeaderBits, 'left-msb')'; 
            payload = int8(randi([0 1], numPayloadBits, 1));
            currentFrame = [header; payload];
            msg = [msg; currentFrame];
            if i > numWarmUp, validTxFrames{end+1} = double(currentFrame); end
        end
        txWaveform = tmWaveGen(msg);
        
        %% 4. 信道
        if isfield(opt, 'cfo'), cfo_val = double(opt.cfo); else, cfo_val = 0; end
        if isfield(opt, 'phaseOffset'), phase_val = double(opt.phaseOffset) * (pi/180); else, phase_val = 0; end
        if cfo_val ~= 0 || phase_val ~= 0
            pfo = comm.PhaseFrequencyOffset('FrequencyOffset', cfo_val, 'PhaseOffset', phase_val, 'SampleRate', Fs);
            txWithCFO = pfo(txWaveform);
        else, txWithCFO = txWaveform; end
        
        if isfield(opt, 'delay'), delay_val = double(opt.delay); else, delay_val = 0; end
        if delay_val ~= 0
            varDelay = dsp.VariableFractionalDelay('InterpolationMethod', 'Farrow');
            txWithDelay = varDelay(txWithCFO, delay_val);
        else, txWithDelay = txWithCFO; end
        
        if isfield(opt, 'snr'), snr_val = double(opt.snr); else, snr_val = 100; end
        rxWaveform = awgn(txWithDelay, snr_val, 'measured');
        
        %% 5. 接收机同步
        modStr = string(opt.modType);
        
        if contains(modStr, 'GMSK')
            dPhi = angle(rxWaveform(2:end) .* conj(rxWaveform(1:end-1)));
            estCFO = mean(dPhi) / (2*pi) * Fs;
            pfo_rx = comm.PhaseFrequencyOffset('FrequencyOffset', -estCFO, 'SampleRate', Fs);
            rxSynced = pfo_rx(rxWaveform);
            
            rxFilterDecimationFactor = sps/2;
            rxfilter = comm.RaisedCosineReceiveFilter('RolloffFactor', rolloff, 'InputSamplesPerSymbol', sps, 'DecimationFactor', rxFilterDecimationFactor); 
            filtered = rxfilter(rxSynced);
            
            % GMSK 同步 (拆分写法)
            gmskTimingObj = comm.SymbolSynchronizer(...
                'TimingErrorDetector', 'Early-Late (non-data-aided)', ...
                'SamplesPerSymbol', 2, 'DetectorGain', 1.0, ...
                'Modulation', 'PAM/PSK/QAM', 'DampingFactor', 1, 'NormalizedLoopBandwidth', 0.001);
            fineSynced = gmskTimingObj(filtered);
        else
            if contains(modStr, 'BPSK'), coarseMod = 'BPSK';
            elseif contains(modStr, '8PSK'), coarseMod = '8PSK';
            elseif contains(modStr, 'QPSK') || contains(modStr, 'OQPSK'), coarseMod = 'QPSK';
            else, coarseMod = 'QAM'; end
            
            coarseFreqSync = comm.CoarseFrequencyCompensator('Modulation', coarseMod, 'SampleRate', Fs, 'FrequencyResolution', 1e3); 
            coarseSynced = coarseFreqSync(rxWaveform);
            
            rxFilterDecimationFactor = sps/2;
            rxfilter = comm.RaisedCosineReceiveFilter('RolloffFactor', rolloff, 'InputSamplesPerSymbol', sps, 'DecimationFactor', rxFilterDecimationFactor); 
            filtered = rxfilter(coarseSynced);
            
            if contains(modStr, 'OQPSK'), SyncMod = 'OQPSK'; else, SyncMod = 'PAM/PSK/QAM'; end
            Kp = 1/(pi*(1-((rolloff^2)/4)))*cos(pi*rolloff/2);
            pskTimingObj = comm.SymbolSynchronizer('TimingErrorDetector', 'Gardner (non-data-aided)', ...
                'SamplesPerSymbol', sps/rxFilterDecimationFactor, "DetectorGain", Kp, "Modulation", SyncMod, 'DampingFactor', 1/sqrt(2), 'NormalizedLoopBandwidth', 0.01);
            TimeSynced = pskTimingObj(filtered);
            
            fineMod = modStr; 
            if contains(modStr, 'OQPSK'), fineMod = 'QPSK'; end
            if contains(modStr, 'APSK'), fineMod = 'QAM'; end
            carrierSyncObj = comm.CarrierSynchronizer('Modulation', fineMod, 'SamplesPerSymbol', 1, 'DampingFactor', 1/sqrt(2), 'NormalizedLoopBandwidth', 0.01);
            fineSynced = carrierSyncObj(TimeSynced);
        end
        
       %% 6. 解调
        berVal = -1; errorMsg = "";
        try
            if ~isempty(fineSynced)
                pwr = mean(abs(fineSynced).^2);
                if pwr > 0, fineSynced = fineSynced / sqrt(pwr); end
            end
            tmMod = char(modStr); if contains(tmMod,'GMSK'), tmMod='GMSK'; end
            
            if isfield(opt, 'channelCoding'), tmCode = char(opt.channelCoding); else, tmCode='none'; end
            if strcmpi(tmCode, 'none'), tmCode = 'Uncoded'; end
            
            isHelperSupported = ~contains(tmCode, {'Turbo', 'LDPC'}, 'IgnoreCase', true);
            if isHelperSupported
                if contains(tmMod, 'GMSK')
                    demodobj = HelperCCSDSTMDemodulator('Modulation', tmMod, 'ChannelCoding', tmCode, 'BandwidthTimeProduct', btVal);
                else
                    demodobj = HelperCCSDSTMDemodulator('Modulation', tmMod, 'ChannelCoding', tmCode);
                end
                demodData = demodobj(fineSynced);
                
                % ASM 自动扫描逻辑 (保留，辅助 GMSK 极性修正)
                if hasASM && ~isempty(demodData) && contains(tmMod, 'GMSK')
                    asmBits = [0 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 1 1 1 0 1]';
                    asmBipolar = 2*double(asmBits) - 1; 
                    chkLen = min(5000, length(demodData));
                    snippet = demodData(1:chkLen);
                    bitsRaw = double(snippet < 0); 
                    
                    calcCorr = @(seq) max(abs(xcorr(2*seq-1, asmBipolar)));
                    s0=bitsRaw; s1=~bitsRaw; s2=bitsRaw; s2(2:2:end)=~s2(2:2:end); s3=bitsRaw; s3(1:2:end)=~s3(1:2:end);
                    [~, idx] = max([calcCorr(s0), calcCorr(s1), calcCorr(s2), calcCorr(s3)]);
                    
                    if idx==2, demodData = -1*demodData; 
                    elseif idx==3, flipVec=ones(length(demodData),1); flipVec(2:2:end)=-1; demodData=demodData.*flipVec;
                    elseif idx==4, flipVec=ones(length(demodData),1); flipVec(1:2:end)=-1; demodData=demodData.*flipVec; end
                end
                
                % 译码
                decArgs = {'ChannelCoding', tmCode, 'Modulation', tmMod, ...
                           'NumBytesInTransferFrame', 1115, ...
                           'HasRandomizer', hasRandomizer, ...
                           'HasASM', hasASM};
                if contains(tmCode, 'Convolutional', 'IgnoreCase',true) && isfield(opt, 'ConvolutionalCodeRate')
                     rate = char(opt.ConvolutionalCodeRate); if ~strcmp(rate,'N/A'), decArgs=[decArgs, {'ConvolutionalCodeRate', rate}]; end
                end
                if isfield(opt, 'RSInterleavingDepth'), decArgs=[decArgs, {'RSInterleavingDepth', opt.RSInterleavingDepth}]; end
                
                decoderobj = HelperCCSDSTMDecoder(decArgs{:});
                decodedBits = decoderobj(demodData);
                
                % =========================================================
                % 【核心修正】BER 计算 (加入盲帧对齐搜索)
                % =========================================================
                if ~isempty(decodedBits)
                    txMap = containers.Map('KeyType','double','ValueType','any');
                    for k = 1:length(validTxFrames)
                         fr = validTxFrames{k};
                         id = bi2de(fr(1:8)', 'left-msb');
                         txMap(id) = fr;
                    end
                    
                    % 盲对齐搜索：由于同步会引入随机比特延迟，我们需要滑动窗口找帧头
                    bestBER = 1.0;
                    bestShift = 0;
                    
                    % 仅搜索前 bitsPerFrame 范围内的位移
                    searchRange = 0 : min(bitsPerFrame, length(decodedBits)-bitsPerFrame);
                    
                    % 快速预检：只检查第一帧的帧头是否匹配
                    possibleShifts = [];
                    for shift = searchRange
                        % 提取假设的帧头 (前8位)
                        candidateHeaderBits = decodedBits(shift+1 : shift+8);
                        rxId = bi2de(candidateHeaderBits', 'left-msb');
                        if isKey(txMap, rxId)
                            possibleShifts(end+1) = shift;
                        end
                    end
                    
                    if isempty(possibleShifts)
                        % 如果没找到头，尝试默认 0 偏移 (保底)
                        possibleShifts = 0; 
                    end
                    
                    % 对候选偏移量进行完整 BER 计算
                    for shift = possibleShifts
                        currErrs = 0; currBits = 0;
                        numRx = floor((length(decodedBits)-shift)/bitsPerFrame);
                        
                        for j=1:numRx
                            startIdx = shift + (j-1)*bitsPerFrame + 1;
                            endIdx = startIdx + bitsPerFrame - 1;
                            rxFr = double(decodedBits(startIdx:endIdx));
                            
                            rxId = bi2de(rxFr(1:8)', 'left-msb');
                            if isKey(txMap, rxId)
                                currErrs = currErrs + biterr(txMap(rxId), rxFr);
                                currBits = currBits + bitsPerFrame;
                            end
                        end
                        
                        if currBits > 0
                            thisBER = currErrs / currBits;
                        else
                            thisBER = 0.5;
                        end
                        
                        if thisBER < bestBER
                            bestBER = thisBER;
                            bestShift = shift;
                        end
                        
                        if bestBER == 0, break; end % 找到完美匹配，提前退出
                    end
                    
                    berVal = bestBER;
                    fprintf('[DEBUG] Best Shift: %d, Final BER: %.6f\n', bestShift, berVal);
                else
                    berVal = 0.5;
                end
            else
                berVal = -1; 
            end
        catch ME_BER
            berVal = -2; errorMsg = ME_BER.message;
        end
        
        %% 7. 结果封装 (略，保持不变)
         [Pxx_rx, f_axis] = pwelch(rxWaveform, [], [], 1024, Fs, 'centered');
        ebno = double(opt.snr) - 10*log10(ifelse(contains(modStr,'PSK'), 2, 1)); 
        try, if contains(modStr,'GMSK'), theo_ber = berawgn(ebno,'psk',2,'nondiff'); else, theo_ber = berawgn(ebno,'psk',4,'nondiff'); end; catch, theo_ber=0; end

        makeRow = @(x) reshape(x, 1, []);
        result = struct('success',true, 'ber',berVal, 'ber_theo',theo_ber);
        result.spectrum = struct('f', makeRow(f_axis), 'p_rx', makeRow(10*log10(Pxx_rx)));
        if contains(modStr, 'GMSK'), pts = rxSynced(1:min(2000,end)); else, pts = fineSynced(end-min(1000,end)+1:end); end
        result.constellation_synced = struct('i', makeRow(real(pts)), 'q', makeRow(imag(pts)));
        json_str = jsonencode(result);
        fprintf('======================================================\n');
        
    catch ME
        json_str = jsonencode(struct('success',false, 'error',ME.message));
    end
end

function out = ifelse(condition, trueVal, falseVal)
    if condition, out = trueVal; else, out = falseVal; end
end
        
    catch ME
        json_str = jsonencode(struct('success',false, 'error',ME.message));
    end
end

function out = ifelse(condition, trueVal, falseVal)
    if condition, out = trueVal; else, out = falseVal; end
end