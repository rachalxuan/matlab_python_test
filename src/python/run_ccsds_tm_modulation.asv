function json_str = run_ccsds_tm_modulation(paramsJson)
    % run_ccsds_tm_modulation 
    % 发送端：智能切换 FACM/TM 模式
    % 接收端：仿照 CCSDS TM 官方例程构建同步链路
    
    tStart = tic;
    try
        %% 1. 解析参数
        if nargin < 1 || isempty(paramsJson)
            error('No parameters received');
        end
        opt = jsondecode(paramsJson);
        
        % 基础参数转换
        makeNum = @(f) str2double(strrep(string(f), ',', '')); 
        if ischar(opt.symbolRate), fSym = makeNum(opt.symbolRate); else, fSym = double(opt.symbolRate); end
        if ischar(opt.sps), sps = makeNum(opt.sps); else, sps = double(opt.sps); end
        
        hasRandomizer = false; if isfield(opt, 'hasRandomizer'), hasRandomizer = opt.hasRandomizer; end
        hasASM = false; if isfield(opt, 'hasASM'), hasASM = opt.hasASM; end

        %% 2. 发送端：智能路由 (Smart Routing)
        % 目的：为了生成波形。因为 TM 模式无法生成 APSK，所以如果是 APSK，我们必须用 FACM 生成。
        
        args = {
            'SamplesPerSymbol', sps, ...
            'HasRandomizer', hasRandomizer, ...
            'HasASM', hasASM
        };
        
        isAPSK = contains(opt.modType, 'APSK');
        
        if isAPSK
            % --- 分支 A: APSK (使用 FACM 生成) ---
            % 即使我们想测试 TM 接收机，发送端也得先能发出 APSK 信号才行
            if isfield(opt, 'acmFormat')
                acmFmt = double(opt.acmFormat);
            else
                acmFmt = 14; 
            end
            args = [args, { ...
                'WaveformSource', 'flexible advanced coding and modulation', ...
                'ACMFormat', acmFmt, ...
                'NumBytesInTransferFrame', 1115, ... % FACM 帧长
                'PulseShapingFilter', 'Root Raised Cosine' ... % 必须开滤波器
            }];
            % 这里的 Rolloff 默认是 0.35
            rolloff = 0.35;
        else
            % --- 分支 B: PSK/QAM (使用 TM 生成) ---
            args = [args, {'WaveformSource', 'synchronization and channel coding'}];
            args = [args, {'NumBytesInTransferFrame', 1115}]; % TM 帧长
            
            modStr = string(opt.modType);
            args = [args, {'Modulation', modStr}];
            
            % 编码参数
            if isfield(opt, 'channelCoding')
                codeStr = lower(string(opt.channelCoding));
            else
                codeStr = 'none';
            end
            args = [args, {'ChannelCoding', codeStr}];
            
            % 滚降系数处理
            if isfield(opt, 'RolloffFactor')
                rolloff = double(opt.RolloffFactor);
            else
                rolloff = 0.5; % TM 标准常用 0.5，FACM 常用 0.35
            end
            args = [args, {'RolloffFactor', rolloff}];
            
            % 针对 BPSK/QPSK 等补充参数
            switch modStr
                case {'BPSK', 'QPSK', '8PSK', 'OQPSK'}
                    args = [args, {'FilterSpanInSymbols', 10}];
            end
             
             % 补充 LDPC/Turbo 参数 (略，保持你原有的逻辑)
             if contains(codeStr, {'turbo', 'ldpc'}) && isfield(opt, 'CodeRate')
                 args = [args, {'CodeRate', string(opt.CodeRate)}];
             end
        end
        
        % 初始化生成器
        tmWaveGen = ccsdsTMWaveformGenerator(args{:});
        
        %% 3. 生成数据与波形
        Fs = fSym * sps;
        
        % 动态获取输入比特长度
        bitsPerFrame = tmWaveGen.NumInputBits;
        
        % 定义帧头 (用于可视化检查)
        numHeaderBits = 8; % 使用 32 位 ASM 作为简单的视觉标记
        numMessagesInBlock = 2^numHeaderBits;
        numPayloadBits = bitsPerFrame - numHeaderBits;
        
        
        % 生成 4 帧数据
        numFrames = 4;
        msg = [];
        
        for i = 1:numFrames
                % 简单的计数器头
                header = de2bi(mod(i-1, numMessagesInBlock), numHeaderBits, 'left-msb')'; 
                payload = int8(randi([0 1], numPayloadBits, 1));
                msg = [msg; header; payload];
        end
        % 生成发送波形
        txWaveform = tmWaveGen(msg);
        
        %% 4. 信道损伤 (Channel Impairments)
         % ==========================================
        % 1. 引入 载波频率偏移 (CFO)
        % ==========================================
        % 获取用户输入的频偏，默认为 0
        if isfield(opt, 'cfo')
            cfo_val = double(opt.cfo);
        else
            cfo_val = 0; 
        end
        % 相位偏移
        if isfield(opt, 'phaseOffset')
            phase_val = double(opt.phaseOffset) * (pi/180); % 前端输入角度，转弧度
        else
            %phase_val = 0; 
             phase_val = pi/8;      % 固定 pi/8
        end
        if cfo_val ~= 0 || phase_val ~= 0
            % 创建频偏对象 (使用 comm.PhaseFrequencyOffset)
            pfo = comm.PhaseFrequencyOffset(...
                'FrequencyOffset', cfo_val, ...
                'PhaseOffset', phase_val, ...
                'SampleRate', Fs);
            
            % 应用频偏
            txWithCFO = pfo(txWaveform);
        else
            txWithCFO = txWaveform;
        end
        
        % ==========================================
        % 2. 引入 定时偏差 (Timing Delay)
        % ==========================================
        % 获取用户输入的延时（可以是小数，例如 0.5 个采样点）
        if isfield(opt, 'delay')
            delay_val = double(opt.delay);
        else
            delay_val = 0; 
        end
        
        if delay_val ~= 0
            % 创建分数倍延时对象 (使用 dsp.VariableFractionalDelay)
            % 它可以模拟非整数倍的采样延迟，非常真实
            varDelay = dsp.VariableFractionalDelay(...
                'InterpolationMethod', 'Farrow');
            
            % 应用延时 (注意：varDelay需要列向量处理逻辑，有时需要重置)
            % 这里简单处理：
            txWithDelay = varDelay(txWithCFO, delay_val);
        else
            txWithDelay = txWithCFO;
        end
        
        % ==========================================
        % 3. 添加 高斯白噪声 (AWGN)
        % ==========================================
        if isfield(opt, 'snr')
            snr_val = double(opt.snr);
        else
            snr_val = 100; % 默认极其纯净
        end
        
        % 最终的接收信号 rxWaveform
        rxWaveform = awgn(txWithDelay, snr_val, 'measured');
        
        %% 5. 接收机处理 
        % -------------------------------------------------------------
        % 关键修改：为了防止 "Changing value of a nontunable property" 错误，
        % 我们不重用旧对象，而是根据当前的调制参数，每次都创建全新的接收机对象。
        % -------------------------------------------------------------
        
        % --- A. 粗频偏同步 (Coarse Frequency Synchronization) ---
        modStr = string(opt.modType);
        
        % 动态映射：将 APSK 等复杂调制映射为粗频偏支持的通用模式
        if contains(modStr, 'BPSK')
            coarseMod = 'BPSK';
        elseif contains(modStr, '8PSK')
            coarseMod = '8PSK';
        elseif contains(modStr, 'QPSK') || contains(modStr, 'OQPSK')
            coarseMod = 'QPSK';
        else
            % 对于 16APSK, 32APSK, GMSK，统一伪装成 QAM
            coarseMod = 'QAM'; 
        end
        
        % [重点] 直接由构造函数生成新对象，覆盖旧变量，避免锁定问题
        coarseFreqSync = comm.CoarseFrequencyCompensator( ...
            'Modulation', coarseMod, ... 
            'SampleRate', Fs, ...
            'FrequencyResolution', 1e3); 
        
        [coarseSynced, coarseFreqEst] = coarseFreqSync(rxWaveform);
        
        % --- B. 接收滤波 (Rx Filter) ---
        % 同样新建对象，因为 RolloffFactor 也是不可调属性
        rxfilter = comm.RaisedCosineReceiveFilter( ...
            'RolloffFactor', rolloff, ...
            'FilterSpanInSymbols', 10, ...
            'InputSamplesPerSymbol', sps, ...
            'DecimationFactor', 1); 
        
        % 归一化增益
        b = coeffs(rxfilter);
        rxfilter.Gain = sum(b.Numerator);
        
        filtered = rxfilter(coarseSynced);
        
        % --- C. 符号定时同步 (Symbol Timing Synchronization) ---
        symsyncobj = comm.SymbolSynchronizer( ...
            'TimingErrorDetector', 'Gardner (non-data-aided)', ...
            'SamplesPerSymbol', sps, ...
            'DampingFactor', 1/sqrt(2), ...
            'NormalizedLoopBandwidth', 0.01);
            
        [TimeSynced, timeDelayEst] = symsyncobj(filtered);
        
        % --- D. 精细频偏与相位跟踪 (Fine Frequency Synchronization) ---
        % -----------------------------------------------------------------
        % 关键修复：
        % 1. 对于 OQPSK：因为输入是 1 SPS (Gardner 输出)，无法表示半个符号偏移，
        %    且此时 IQ 已对齐，直接当做 QPSK 处理即可。
        % 2. 对于 APSK：CarrierSynchronizer 不支持 'APSK'，统一伪装成 'QAM'。
        % -----------------------------------------------------------------
        
        fineMod = modStr; % 默认情况
        
        if contains(modStr, 'OQPSK')
            % 【修复 OQPSK 错误】
            % OQPSK 在 1 SPS 下看起来和 QPSK 一样，必须映射为 QPSK 才能避开 "even samples" 检查
            fineMod = 'QPSK'; 
            
        elseif contains(modStr, 'APSK')
            % 【修复 16APSK 错误】
            % 载波同步器不支持 16APSK，伪装成 QAM (虽然效果一般，但能跑通)
            fineMod = 'QAM';
            
        elseif contains(modStr, 'GMSK')
            % GMSK 在去旋转后通常当做 BPSK 或 QPSK 处理，这里暂定 QPSK 演示
            fineMod = 'QPSK'; 
        end
        
        % 此时 fineMod 必定是有效值 (BPSK, QPSK, 8PSK, QAM)
        fineFreqSync = comm.CarrierSynchronizer( ...
            'Modulation', fineMod, ... 
            'SamplesPerSymbol', 1, ...
            'DampingFactor', 1/sqrt(2), ...
            'NormalizedLoopBandwidth', 0.01);
        
        [fineSynced, phaseErr] = fineFreqSync(TimeSynced);
        
        %% 6. 数据提取与可视化
        
        % 1. 频谱图 (对比 Tx 和 Rx)
        [Pxx_rx, f_axis] = pwelch(rxWaveform, [], [], 1024, Fs, 'centered');
        Pxx_rx_dB = 10*log10(Pxx_rx);
        [Pxx_tx, ~] = pwelch(txWaveform, [], [], 1024, Fs, 'centered');
        Pxx_tx_dB = 10*log10(Pxx_tx);
        
        % 2. 星座图
        % 截取最后 1000 个点（跳过收敛过程中的抖动）
        L_max = 1000;
        
        % A. 修复前 (Raw)：直接对 rxWaveform 下采样，只看物理层损伤
        raw_idx = 1 : sps : length(rxWaveform);
        raw_pts = rxWaveform(raw_idx);
        raw_pts = raw_pts(1:min(L_max, end));
        % 简单归一化方便显示
        scale_raw = 1 / sqrt(mean(abs(raw_pts).^2));
        raw_pts = raw_pts * scale_raw;
        
        % B. 修复后 (Synced)：经过了完整的 TM 接收机链路
        synced_pts = fineSynced(end-min(L_max, length(fineSynced))+1 : end);
        
        % 3. 构造 JSON
        makeRow = @(x) reshape(x, 1, []);
        result = struct();
        result.success = true;
        result.info = sprintf("Generated: %s via %s (Rx Chain: TM Standard)", opt.modType, ifelse(isAPSK,'FACM','TM'));
        
        result.spectrum = struct('f', makeRow(f_axis), 'p_rx', makeRow(Pxx_rx_dB), 'p_tx', makeRow(Pxx_tx_dB));
        result.constellation_raw = struct('i', makeRow(real(raw_pts)), 'q', makeRow(imag(raw_pts)));
        result.constellation_synced = struct('i', makeRow(real(synced_pts)), 'q', makeRow(imag(synced_pts)));
        
        % 统计信息
        result.stats = struct('Fs', Fs, 'CodeRate', 0, 'ElapsedTime', toc(tStart));
        
        json_str = jsonencode(result);
        
    catch ME
        err = struct('success', false, 'error', ME.message, 'stack', ME.stack(1).name, 'line', ME.stack(1).line);
        json_str = jsonencode(err);
    end
end

% 简单的辅助函数
function out = ifelse(condition, trueVal, falseVal)
    if condition
        out = trueVal;
    else
        out = falseVal;
    end
end